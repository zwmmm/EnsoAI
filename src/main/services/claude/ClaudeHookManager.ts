import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';
import { app } from 'electron';

interface StatusLineConfig {
  type: 'command' | 'text';
  command?: string;
  text?: string;
  padding?: number;
}

interface ClaudeSettings {
  hooks?: {
    Stop?: Array<{
      matcher?: string;
      hooks: Array<{
        type: 'command' | 'prompt';
        command?: string;
        prompt?: string;
        timeout?: number;
      }>;
    }>;
    PermissionRequest?: Array<{
      matcher?: string;
      hooks: Array<{
        type: 'command' | 'prompt';
        command?: string;
        prompt?: string;
        timeout?: number;
      }>;
    }>;
    [key: string]: unknown;
  };
  statusLine?: StatusLineConfig;
  [key: string]: unknown;
}

interface StatusLineBackup {
  originalConfig: StatusLineConfig | null;
  backupTime: string;
}

// Hook is identified by the script path 'ensoai-hook' in the command
// Use .cjs extension to force CommonJS mode regardless of user's package.json "type" setting
const HOOK_SCRIPT_NAME = 'ensoai-hook.cjs';
const HOOK_MARKER = 'ensoai-hook';

// Legacy script name for migration
const LEGACY_SCRIPT_NAME = 'ensoai-stop.cjs';
const LEGACY_MARKER = 'ensoai-stop';

function getClaudeConfigDir(): string {
  if (process.env.CLAUDE_CONFIG_DIR) {
    return process.env.CLAUDE_CONFIG_DIR;
  }
  return path.join(os.homedir(), '.claude');
}

function getClaudeSettingsPath(): string {
  return path.join(getClaudeConfigDir(), 'settings.json');
}

function getHooksDir(): string {
  return path.join(getClaudeConfigDir(), 'hooks');
}

function getHookScriptPath(): string {
  return path.join(getHooksDir(), HOOK_SCRIPT_NAME);
}

function getLegacyHookScriptPath(): string {
  return path.join(getHooksDir(), LEGACY_SCRIPT_NAME);
}

/**
 * Node.js hook script content - runs on all platforms
 * Handles: Stop, PermissionRequest (AskUserQuestion)
 */
function getHookScriptContent(): string {
  const ideDir = path.join(getClaudeConfigDir(), 'ide');
  // Use forward slashes for path in JS (works on all platforms)
  const ideDirJs = ideDir.replace(/\\/g, '/');

  return `// EnsoAI Hook - Sends agent notifications
// Auto-generated by EnsoAI - Do not edit manually
// Requires Node.js in PATH
// Handles: Stop, PermissionRequest (AskUserQuestion)

const fs = require('fs');
const path = require('path');
const http = require('http');

const IDE_DIR = '${ideDirJs}';

async function main() {
  // Read JSON from stdin
  let input = '';
  process.stdin.setEncoding('utf8');
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let data;
  try {
    data = JSON.parse(input);
  } catch {
    process.exit(0);
  }

  const sessionId = data.session_id;
  if (!sessionId) {
    process.exit(0);
  }

  // Find EnsoAI lockfiles and send notification to ALL instances
  if (!fs.existsSync(IDE_DIR)) {
    process.exit(0);
  }

  const lockfiles = fs.readdirSync(IDE_DIR).filter(f => f.endsWith('.lock'));
  for (const lockfile of lockfiles) {
    try {
      const content = JSON.parse(fs.readFileSync(path.join(IDE_DIR, lockfile), 'utf-8'));
      if (content.ideName === 'EnsoAI') {
        const port = path.basename(lockfile, '.lock');
        // Send POST request with full data
        const postData = JSON.stringify(data);
        const req = http.request({
          hostname: '127.0.0.1',
          port: parseInt(port),
          path: '/agent-hook',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(postData),
          },
          timeout: 2000,
        });
        req.on('error', () => {});
        req.write(postData);
        req.end();
        break;
      }
    } catch {
      // Ignore errors, try next lockfile
    }
  }
}

main().catch(() => process.exit(0));
`;
}

function ensureHookScript(): string {
  const hooksDir = getHooksDir();
  const scriptPath = getHookScriptPath();

  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }

  // Migrate legacy script if exists
  const legacyScriptPath = getLegacyHookScriptPath();
  if (fs.existsSync(legacyScriptPath)) {
    try {
      fs.unlinkSync(legacyScriptPath);
      console.log('[ClaudeHookManager] Removed legacy script:', LEGACY_SCRIPT_NAME);
    } catch (err) {
      console.warn('[ClaudeHookManager] Failed to remove legacy script:', err);
    }
  }

  // TODO(v0.3.0): Remove legacy .js cleanup
  const legacyScriptPath2 = path.join(hooksDir, 'ensoai-stop.js');
  if (fs.existsSync(legacyScriptPath2)) {
    fs.unlinkSync(legacyScriptPath2);
  }

  fs.writeFileSync(scriptPath, getHookScriptContent(), { mode: 0o755 });

  return scriptPath;
}

/**
 * Generate hook command that runs the script using Node.js
 * Requires Node.js to be installed and available in PATH
 */
function generateHookCommand(): string {
  const scriptPath = getHookScriptPath();
  // Use forward slashes for cross-platform compatibility
  const scriptPathCmd = scriptPath.replace(/\\/g, '/');

  return `node "${scriptPathCmd}"`;
}

/**
 * Check if Claude CLI is installed by verifying .claude directory exists
 * This prevents creating config files for users who don't have Claude installed
 */
export function isClaudeInstalled(): boolean {
  const configDir = getClaudeConfigDir();
  return fs.existsSync(configDir);
}

/**
 * Ensure the Stop hook is configured in Claude settings
 * Returns true if hook was added or already exists
 * Returns false if Claude is not installed (skips setup)
 */
export function ensureStopHook(): boolean {
  // Skip hook setup if Claude is not installed
  if (!isClaudeInstalled()) {
    console.log('[ClaudeHookManager] Claude not installed, skipping hook setup');
    return false;
  }

  try {
    const settingsPath = getClaudeSettingsPath();

    // Read existing settings or create new
    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // IMPORTANT: Migrate settings.json BEFORE deleting legacy script files
    // This ensures atomic migration - if settings update fails, script still exists
    let needSave = false;
    if (settings.hooks?.Stop) {
      const originalLength = settings.hooks.Stop.length;
      // Remove old .js and legacy .cjs references
      settings.hooks.Stop = settings.hooks.Stop.filter(
        (hookGroup) =>
          !hookGroup.hooks?.some(
            (hook) =>
              hook.type === 'command' &&
              (hook.command?.includes('ensoai-stop.js') || hook.command?.includes(LEGACY_MARKER))
          )
      );
      if (settings.hooks.Stop.length < originalLength) {
        console.log('[ClaudeHookManager] Cleaned up legacy hook references from settings');
        needSave = true;
      }
      // Clean up empty Stop array
      if (settings.hooks.Stop.length === 0) {
        delete settings.hooks.Stop;
      }
    }

    // Save migrated settings BEFORE deleting script files
    if (needSave) {
      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
        mode: 0o600,
      });
    }

    // Now safe to update script files (settings.json is already clean)
    ensureHookScript();

    // Check if already configured (with NEW hook marker only, not legacy)
    const hasCurrentHook = settings.hooks?.Stop?.some((hookGroup) =>
      hookGroup.hooks?.some(
        (hook) => hook.type === 'command' && hook.command?.includes(HOOK_MARKER)
      )
    );
    if (hasCurrentHook) {
      return true;
    }

    // Initialize hooks object if needed
    if (!settings.hooks) {
      settings.hooks = {};
    }
    if (!settings.hooks.Stop) {
      settings.hooks.Stop = [];
    }

    // Add our hook - marker is embedded in the command for identification
    const hookCommand = generateHookCommand();
    settings.hooks.Stop.push({
      matcher: '',
      hooks: [
        {
          type: 'command',
          // Marker is checked via includes(HOOK_MARKER), embedded in command itself
          command: hookCommand,
          timeout: 5,
        },
      ],
    });

    // Ensure directory exists
    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    // Write settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure Stop hook:', error);
    return false;
  }
}

/**
 * Remove EnsoAI Stop hook from Claude settings
 */
export function removeStopHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    if (!settings.hooks?.Stop) {
      return true;
    }

    // Filter out our hook (both current and legacy)
    settings.hooks.Stop = settings.hooks.Stop.filter(
      (hookGroup) =>
        !hookGroup.hooks?.some(
          (hook) =>
            hook.type === 'command' &&
            (hook.command?.includes(HOOK_MARKER) ||
              hook.command?.includes(LEGACY_MARKER) ||
              hook.command?.includes('ensoai-stop'))
        )
    );

    // Clean up empty arrays
    if (settings.hooks.Stop.length === 0) {
      delete settings.hooks.Stop;
    }
    if (Object.keys(settings.hooks).length === 0) {
      delete settings.hooks;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove Stop hook:', error);
    return false;
  }
}

// ============================================================================
// Status Line Hook Management
// ============================================================================

const STATUSLINE_SCRIPT_NAME = 'enso-statusline.cjs';
const STATUSLINE_BACKUP_FILE = 'claude-statusline-backup.json';

function getStatusLineScriptPath(): string {
  return path.join(getHooksDir(), STATUSLINE_SCRIPT_NAME);
}

function getStatusLineBackupPath(): string {
  return path.join(app.getPath('userData'), STATUSLINE_BACKUP_FILE);
}

/**
 * Generate status line script content
 */
function getStatusLineScriptContent(): string {
  const ideDir = path.join(getClaudeConfigDir(), 'ide');
  const ideDirJs = ideDir.replace(/\\/g, '/');

  return `// EnsoAI Status Line Hook - Forwards status data to EnsoAI
// Auto-generated by EnsoAI - Do not edit manually

const fs = require('fs');
const path = require('path');
const http = require('http');

const IDE_DIR = '${ideDirJs}';

async function main() {
  // Read JSON from stdin
  let input = '';
  process.stdin.setEncoding('utf8');
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let data;
  try {
    data = JSON.parse(input);
  } catch {
    // Output empty line if parsing fails
    console.log('');
    process.exit(0);
  }

  // Find EnsoAI lockfiles and send status update to ALL instances
  if (fs.existsSync(IDE_DIR)) {
    const lockfiles = fs.readdirSync(IDE_DIR).filter(f => f.endsWith('.lock'));
    for (const lockfile of lockfiles) {
      try {
        const content = JSON.parse(fs.readFileSync(path.join(IDE_DIR, lockfile), 'utf-8'));
        if (content.ideName === 'EnsoAI') {
          const port = path.basename(lockfile, '.lock');
          const postData = JSON.stringify(data);
          const req = http.request({
            hostname: '127.0.0.1',
            port: parseInt(port),
            path: '/status-line',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(postData),
            },
            timeout: 1000,
          });
          req.on('error', () => {});
          req.write(postData);
          req.end();
          // Don't break - send to all EnsoAI instances
        }
      } catch {
        // Ignore errors, try next lockfile
      }
    }
  }

  // Output empty line - don't override Claude's native status line display
  console.log('');
}

main().catch(() => {
  console.log('');
  process.exit(0);
});
`;
}

function ensureStatusLineScript(): string {
  const hooksDir = getHooksDir();
  const scriptPath = getStatusLineScriptPath();

  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }

  // TODO(v0.3.0): Remove legacy .js cleanup
  const legacyScriptPath = path.join(hooksDir, 'enso-statusline.js');
  if (fs.existsSync(legacyScriptPath)) {
    fs.unlinkSync(legacyScriptPath);
  }

  fs.writeFileSync(scriptPath, getStatusLineScriptContent(), { mode: 0o755 });
  return scriptPath;
}

/**
 * Generate status line command
 */
function generateStatusLineCommand(): string {
  const scriptPath = getStatusLineScriptPath();
  const scriptPathCmd = scriptPath.replace(/\\/g, '/');
  return `node "${scriptPathCmd}"`;
}

/**
 * Check if our status line hook is configured
 */
function isStatusLineHookConfigured(settings: ClaudeSettings): boolean {
  return (
    settings.statusLine?.type === 'command' &&
    (settings.statusLine?.command?.includes(STATUSLINE_SCRIPT_NAME) ?? false)
  );
}

/**
 * Backup existing status line config
 */
function backupStatusLineConfig(currentConfig: StatusLineConfig | undefined): void {
  const backupPath = getStatusLineBackupPath();

  // Don't backup if already backed up
  if (fs.existsSync(backupPath)) {
    return;
  }

  const backup: StatusLineBackup = {
    originalConfig: currentConfig ?? null,
    backupTime: new Date().toISOString(),
  };

  const userDataDir = app.getPath('userData');
  if (!fs.existsSync(userDataDir)) {
    fs.mkdirSync(userDataDir, { recursive: true });
  }

  fs.writeFileSync(backupPath, JSON.stringify(backup, null, 2), { mode: 0o600 });
  console.log('[ClaudeHookManager] Status line config backed up');
}

/**
 * Restore status line config from backup
 */
function restoreStatusLineConfig(): StatusLineConfig | null | undefined {
  const backupPath = getStatusLineBackupPath();

  if (!fs.existsSync(backupPath)) {
    return undefined; // No backup exists
  }

  try {
    const content = fs.readFileSync(backupPath, 'utf-8');
    const backup: StatusLineBackup = JSON.parse(content);

    // Delete backup file after reading
    fs.unlinkSync(backupPath);

    console.log('[ClaudeHookManager] Status line config restored from backup');
    return backup.originalConfig;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to restore status line backup:', error);
    return undefined;
  }
}

/**
 * Ensure status line hook is configured
 */
export function ensureStatusLineHook(): boolean {
  if (!isClaudeInstalled()) {
    console.log('[ClaudeHookManager] Claude not installed, skipping status line hook setup');
    return false;
  }

  try {
    // Ensure script file is up-to-date
    ensureStatusLineScript();

    const settingsPath = getClaudeSettingsPath();

    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // TODO(v0.3.0): Remove legacy .js cleanup from settings.json
    // Clean up legacy .js reference in statusLine (file may have been deleted in previous versions)
    let needSave = false;
    if (
      settings.statusLine?.type === 'command' &&
      settings.statusLine?.command?.includes('enso-statusline.js')
    ) {
      console.log('[ClaudeHookManager] Cleaned up legacy .js statusLine reference from settings');
      delete settings.statusLine;
      needSave = true;
    }

    // Save if we cleaned up legacy reference
    if (needSave) {
      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
        mode: 0o600,
      });
    }

    // Already configured
    if (isStatusLineHookConfigured(settings)) {
      return true;
    }

    // Backup existing config
    backupStatusLineConfig(settings.statusLine);

    // Set our status line config
    settings.statusLine = {
      type: 'command',
      command: generateStatusLineCommand(),
      padding: 0,
    };

    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), { mode: 0o600 });
    console.log('[ClaudeHookManager] Status line hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure status line hook:', error);
    return false;
  }
}

/**
 * Remove status line hook and restore original config
 */
export function removeStatusLineHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    // Only remove if it's our hook
    if (!isStatusLineHookConfigured(settings)) {
      return true;
    }

    // Restore from backup
    const originalConfig = restoreStatusLineConfig();

    if (originalConfig === undefined) {
      // No backup, just delete our config
      delete settings.statusLine;
    } else if (originalConfig === null) {
      // Original had no config
      delete settings.statusLine;
    } else {
      // Restore original config
      settings.statusLine = originalConfig;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), { mode: 0o600 });

    // Remove script file
    const scriptPath = getStatusLineScriptPath();
    if (fs.existsSync(scriptPath)) {
      fs.unlinkSync(scriptPath);
    }

    console.log('[ClaudeHookManager] Status line hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove status line hook:', error);
    return false;
  }
}

/**
 * Check if status line hook is installed
 */
export function isStatusLineHookInstalled(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();
    if (!fs.existsSync(settingsPath)) {
      return false;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);
    return isStatusLineHookConfigured(settings);
  } catch {
    return false;
  }
}

// ============================================================================
// PermissionRequest Hook Management (for AskUserQuestion notifications)
// ============================================================================

/**
 * Check if PermissionRequest hook is configured
 */
function isPermissionRequestHookConfigured(settings: ClaudeSettings): boolean {
  if (!settings.hooks?.PermissionRequest) {
    return false;
  }

  return settings.hooks.PermissionRequest.some((hookGroup) =>
    hookGroup.hooks?.some(
      (hook) =>
        hook.type === 'command' &&
        (hook.command?.includes(HOOK_MARKER) || hook.command?.includes(LEGACY_MARKER))
    )
  );
}

/**
 * Ensure PermissionRequest hook is configured
 */
export function ensurePermissionRequestHook(): boolean {
  if (!isClaudeInstalled()) {
    console.log('[ClaudeHookManager] Claude not installed, skipping PermissionRequest hook setup');
    return false;
  }

  try {
    const settingsPath = getClaudeSettingsPath();

    // Read existing settings or create new
    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // Migrate legacy hook references (ensoai-stop -> ensoai-hook)
    let needSave = false;
    if (settings.hooks?.PermissionRequest) {
      const originalLength = settings.hooks.PermissionRequest.length;
      settings.hooks.PermissionRequest = settings.hooks.PermissionRequest.filter(
        (hookGroup) =>
          !hookGroup.hooks?.some(
            (hook) =>
              hook.type === 'command' &&
              (hook.command?.includes('ensoai-stop.js') || hook.command?.includes(LEGACY_MARKER))
          )
      );
      if (settings.hooks.PermissionRequest.length < originalLength) {
        console.log(
          '[ClaudeHookManager] Cleaned up legacy PermissionRequest hook references from settings'
        );
        needSave = true;
      }
      if (settings.hooks.PermissionRequest.length === 0) {
        delete settings.hooks.PermissionRequest;
      }
    }

    if (needSave) {
      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
        mode: 0o600,
      });
    }

    // Check if already configured (with NEW hook marker only)
    const hasCurrentHook = settings.hooks?.PermissionRequest?.some((hookGroup) =>
      hookGroup.hooks?.some(
        (hook) => hook.type === 'command' && hook.command?.includes(HOOK_MARKER)
      )
    );
    if (hasCurrentHook) {
      return true;
    }

    // Initialize hooks object if needed
    if (!settings.hooks) {
      settings.hooks = {};
    }
    if (!settings.hooks.PermissionRequest) {
      settings.hooks.PermissionRequest = [];
    }

    // Add our hook - reuse the same ensoai-hook.cjs script
    const hookCommand = generateHookCommand();
    settings.hooks.PermissionRequest.push({
      matcher: '',
      hooks: [
        {
          type: 'command',
          command: hookCommand,
          timeout: 5,
        },
      ],
    });

    // Ensure directory exists
    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    // Write settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] PermissionRequest hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure PermissionRequest hook:', error);
    return false;
  }
}

/**
 * Remove PermissionRequest hook from Claude settings
 */
export function removePermissionRequestHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    if (!settings.hooks?.PermissionRequest) {
      return true;
    }

    // Filter out our hook (both current and legacy)
    settings.hooks.PermissionRequest = settings.hooks.PermissionRequest.filter(
      (hookGroup) =>
        !hookGroup.hooks?.some(
          (hook) =>
            hook.type === 'command' &&
            (hook.command?.includes(HOOK_MARKER) || hook.command?.includes(LEGACY_MARKER))
        )
    );

    // Clean up empty PermissionRequest array
    if (settings.hooks.PermissionRequest.length === 0) {
      delete settings.hooks.PermissionRequest;
    }

    // Clean up empty hooks object
    if (Object.keys(settings.hooks).length === 0) {
      delete settings.hooks;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] PermissionRequest hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove PermissionRequest hook:', error);
    return false;
  }
}

/**
 * Check if PermissionRequest hook is installed
 */
export function isPermissionRequestHookInstalled(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();
    if (!fs.existsSync(settingsPath)) {
      return false;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);
    return isPermissionRequestHookConfigured(settings);
  } catch {
    return false;
  }
}
